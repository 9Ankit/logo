import { Injectable, Directive, Input, Output, EventEmitter, HostListener, Component, ViewChild, Renderer2, NgModule } from '@angular/core';
import { HttpClient, HttpHeaders, HttpClientModule } from '@angular/common/http';
import { NSystemService, NeutrinosSeedServicesModule } from 'neutrinos-seed-services';
import { MatDialogRef, MatDialog, MatButtonToggleModule } from '@angular/material';
import signing__default from 'signature_pad';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { FlexLayoutModule } from '@angular/flex-layout';
import { NSheetModule } from 'n-sheet';
import { MatIconModule } from '@angular/material/icon';
import { MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NFileIOService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.checkFileExist = (path, fileName, i, callback) => {
            return window.resolveLocalFileSystemURL(path + fileName, () => {
                let /** @type {?} */ length = 4;
                if (fileName.lastIndexOf('(') > -1) {
                    const /** @type {?} */ isExist = parseInt(fileName.slice((fileName.lastIndexOf('(') + 1), fileName.lastIndexOf(')')), 10);
                    if (!isNaN(isExist)) {
                        i = isExist + 1;
                        if (i > 10 && i < 100) {
                            length += 1;
                        }
                        else if (i > 100) {
                            length += 2;
                        }
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.') - length)) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                    else {
                        i += 1;
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                }
                else {
                    i += 1;
                    fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                    fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                }
                return this.checkFileExist(path, fileName, i, callback);
            }, () => {
                return callback(fileName);
            });
        };
        this.systemService = NSystemService.getInstance();
        this.appProperties = this.systemService.getVal('properties');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    getFileInfo(options) {
        let /** @type {?} */ dataModelURL = this.systemService.getDataModelUrl();
        if (options.metadata) {
            dataModelURL += `${this.appProperties.appName}_${options.entityName}.files?filter={"metadata.key": "${options.metadata.key}"}`;
        }
        else {
            dataModelURL += `${this.appProperties.appName}_${options.entityName}.files/${options.fileId}`;
        }
        return this.http.get(dataModelURL);
    }
    /**
     * @param {?} fileUri
     * @return {?}
     */
    getFormData(fileUri) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(fileUri, (fileEntry) => {
                fileEntry.file((file) => {
                    const /** @type {?} */ reader = new FileReader();
                    reader.onerror = evt => {
                        return reject(evt);
                    };
                    reader.onloadend = evt => {
                        const /** @type {?} */ formData = new FormData();
                        const /** @type {?} */ blob = new Blob([new Uint8Array(reader.result)], { type: file.type });
                        formData.append('file', blob, file.name);
                        return resolve(formData);
                    };
                    reader.readAsArrayBuffer(file);
                });
            }, (error) => {
                return reject(error);
            });
        });
    }
    /**
     * @param {?} cameraOptions
     * @return {?}
     */
    getPicture(cameraOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                navigator.camera.getPicture((imageUri) => {
                    this.getFormData(imageUri).then(res => {
                        return resolve(res);
                    }).catch(err => reject(err));
                }, (error) => {
                    return reject(error);
                }, cameraOptions);
            }, false);
        });
    }
    /**
     * @param {?} scanOptions
     * @return {?}
     */
    scanPicture(scanOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (scanOptions.hasOwnProperty('sourceType') && scanOptions.hasOwnProperty('doUpload')) {
                    scan.scanDoc(scanOptions.sourceType, (imageUri) => {
                        if (scanOptions.doUpload) {
                            this.getFormData(imageUri).then(res => {
                                return resolve(res);
                            }).catch(err => reject(err));
                        }
                        else {
                            resolve(imageUri);
                        }
                    }, (error) => {
                        return reject(error);
                    });
                }
                else {
                    reject('sourceType not found');
                }
            }, false);
        });
    }
    /**
     * @param {?} barcodeOptions
     * @return {?}
     */
    getBarcode(barcodeOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                cordova.plugins.barcodeScanner.scan((result) => {
                    if (result.cancelled) {
                        return reject(result);
                    }
                    else {
                        return resolve(result);
                    }
                }, (error) => {
                    return reject(error);
                }, barcodeOptions);
            }, false);
        });
    }
    /**
     * @param {?} videoOptions
     * @return {?}
     */
    getVideo(videoOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                navigator.device.capture.captureVideo((mediaFiles) => {
                    var /** @type {?} */ imageUri = mediaFiles[0].fullPath;
                    this.getFormData(imageUri).then(res => {
                        return resolve(res);
                    }).catch(err => reject(err));
                }, (error) => {
                    return reject(error);
                }, {});
            }, false);
        });
    }
    /**
     * @param {?} ttsOptions
     * @return {?}
     */
    getTts(ttsOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (ttsOptions.hasOwnProperty('text')) {
                    TTS.speak(ttsOptions).then(() => {
                        return resolve('success');
                    }, (reason) => {
                        return reject(reason);
                    });
                }
                else {
                    reject('text not found');
                }
            }, false);
        });
    }
    /**
     * @param {?} shakeOptions
     * @return {?}
     */
    getShake(shakeOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (shakeOptions.hasOwnProperty('start') && shakeOptions.hasOwnProperty('sensitivity')) {
                    if (shakeOptions.start) {
                        shake.startWatch(() => {
                            return resolve('success');
                        }, shakeOptions.sensitivity, () => {
                            return reject('error');
                        });
                    }
                    else {
                        shake.stopWatch();
                    }
                }
                else {
                    reject('start or sensitivity not found');
                }
            }, false);
        });
    }
    /**
     * @param {?} ocrOptions
     * @return {?}
     */
    getOcr(ocrOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (ocrOptions.hasOwnProperty('uriOrBase') && ocrOptions.hasOwnProperty('returnType')) {
                    navigator.camera.getPicture((imageData) => {
                        textocr.recText(ocrOptions.uriOrBase, ocrOptions.returnType, imageData, (recognizedText) => {
                            return resolve(recognizedText);
                        }, (message) => {
                            return reject(message);
                        });
                    }, (message) => {
                        return reject(message);
                    }, ocrOptions);
                }
                else {
                    reject('uriOrBase or returnType not found');
                }
            }, false);
        });
    }
    /**
     * @param {?} fingerprintOptions
     * @return {?}
     */
    getFingerprint(fingerprintOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (fingerprintOptions.hasOwnProperty('clientId') && fingerprintOptions.hasOwnProperty('clientSecret')) {
                    Fingerprint.isAvailable((result) => {
                        Fingerprint.show(fingerprintOptions, () => {
                            return resolve('success');
                        }, (err) => {
                            return reject(err);
                        });
                    }, (message) => {
                        return reject(message);
                    });
                }
                else {
                    reject('clientId or clientSecret not found');
                }
            }, false);
        });
    }
    /**
     * @param {?} options
     * @return {?}
     */
    upload(options) {
        return new Promise((resolve, reject) => {
            let /** @type {?} */ body = new FormData();
            if (options.formData) {
                body = options.formData;
            }
            else if (options.files) {
                body.append('file', options.files);
            }
            else {
                reject('No file selected!');
            }
            if (options.metadata) {
                body.append('metadata', JSON.stringify(options.metadata));
            }
            const /** @type {?} */ headers = { 'Content-Type': 'no-content' };
            const /** @type {?} */ url = this.systemService.getFileIOUrl() + `${options.entityName}`;
            let /** @type {?} */ temp_headers = { headers: this.setHeaders(headers) };
            this.http.post(url, body, temp_headers)
                .subscribe(res => resolve(res), err => reject(err));
        });
    }
    /**
     * @param {?} options
     * @return {?}
     */
    download(options) {
        return new Promise((resolve, reject) => {
            if (options.entityName && (options.metadata || options.fileId)) {
                this.getFileInfo(options).subscribe((res) => {
                    if (options.metadata) {
                        res = res[res.length - 1];
                    }
                    else {
                        res = res.result;
                    }
                    const /** @type {?} */ fileInfo = {
                        contentType: '',
                        filename: ''
                    };
                    if (res && res['contentType'] && res['filename']) {
                        fileInfo['contentType'] = res['contentType'];
                        fileInfo['filename'] = res['filename'];
                        let /** @type {?} */ fileIOURL = this.systemService.getFileIOUrl();
                        if (options.metadata) {
                            fileIOURL += `${options.entityName}?metadataFilter={"metadata.key": "${options.metadata.key}"}`;
                        }
                        else {
                            fileIOURL += `${options.entityName}/${options.fileId}`;
                        }
                        const /** @type {?} */ headers = {
                            'Accept': fileInfo.contentType
                        };
                        this.http.get(fileIOURL, { headers: this.setHeaders(headers), responseType: 'blob' }).subscribe((response) => {
                            const /** @type {?} */ blob = new Blob([response.body], { type: fileInfo.contentType });
                            this.saveFile(blob, fileInfo.filename).then((resp) => {
                            }).catch(err => reject(err));
                        }, err => reject(err));
                    }
                    else {
                        reject('fileInfo not exit');
                    }
                }, err => reject(err));
            }
            else {
                return reject('download options not found');
            }
        });
    }
    /**
     * @param {?} data
     * @param {?} filename
     * @return {?}
     */
    saveFile(data, filename) {
        return new Promise((resolve, reject) => {
            if (this.systemService.checkDevice() == 'mobile') {
                const /** @type {?} */ storageLocation = this.systemService.isAndroid() ? cordova.file.externalRootDirectory : cordova.file.documentsDirectory;
                this.createDirectory(storageLocation, this.appProperties.appName, filename, data)
                    .then(res => resolve(res))
                    .catch(err => reject(err));
            }
            else {
                this.saveToBrowser(data, filename).then(res => resolve(res));
            }
        });
    }
    /**
     * @param {?} data
     * @param {?} fileName
     * @return {?}
     */
    saveToBrowser(data, fileName) {
        return new Promise((resolve) => {
            // Edge 20+
            const /** @type {?} */ isEdge = !(/*@cc_on!@*/ false || !!document['documentMode']) && !!window.StyleMedia;
            if (isEdge) {
                window.navigator.msSaveBlob(data, fileName);
            }
            else {
                const /** @type {?} */ downloadURL = window.URL.createObjectURL(data);
                const /** @type {?} */ anchor = document.createElement('a');
                document.body.appendChild(anchor);
                anchor.style.display = 'none';
                anchor.download = fileName;
                anchor.href = downloadURL;
                anchor.click();
                window.URL.revokeObjectURL(downloadURL);
                document.body.removeChild(anchor);
                anchor.remove();
            }
            return resolve('download complete');
        });
    }
    /**
     * @param {?} rootDirectory
     * @param {?} appName
     * @param {?} fileName
     * @param {?} data
     * @return {?}
     */
    createDirectory(rootDirectory, appName, fileName, data) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(rootDirectory, (fileSystem) => {
                fileSystem.getDirectory(appName, { create: true }, (dirEntry) => {
                    this.checkFileExist(dirEntry.nativeURL, fileName, 0, (newFileName) => {
                        dirEntry.getFile(newFileName, { create: true }, (targetFile) => {
                            targetFile.createWriter((fileWriter) => {
                                fileWriter.onwriteend = () => {
                                    return resolve(targetFile.toURL());
                                };
                                fileWriter.onerror = (err) => {
                                    return reject(err);
                                };
                                fileWriter.write(data);
                            });
                        });
                    });
                }, err => reject(err));
            }, err => reject(err));
        });
    }
    /**
     * @param {?} headerJSON
     * @return {?}
     */
    setHeaders(headerJSON) {
        let /** @type {?} */ headers = new HttpHeaders();
        for (const /** @type {?} */ key in headerJSON) {
            if (key) {
                headers = headers.set(key, headerJSON[key]);
            }
        }
        return headers;
    }
}
NFileIOService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NFileIOService.ctorParameters = () => [
    { type: HttpClient, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NCameraDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getPicture()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getPicture() {
        return new Promise((resolve, reject) => {
            this.fsv.getPicture(this.cameraOptions).then(res => {
                const /** @type {?} */ options = {
                    'formData': res,
                    'entityName': this.cameraOptions.entityName,
                    'metadata': this.cameraOptions.metadata
                };
                this.fsv.upload(options)
                    .then(uri => resolve(uri))
                    .catch(err => reject(err));
            }).catch(err => reject(err));
        });
    }
}
NCameraDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-camera]'
            },] },
];
/** @nocollapse */
NCameraDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NCameraDirective.propDecorators = {
    "cameraOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NDownloadDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.downloadFile()
            .then(res => this.onsuccess.emit(res))
            .catch(err => this.onerror.emit(err));
    }
    /**
     * @return {?}
     */
    downloadFile() {
        return this.fsv.download(this.downloadOptions);
    }
}
NDownloadDirective.decorators = [
    { type: Directive, args: [{ selector: '[n-download]' },] },
];
/** @nocollapse */
NDownloadDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NDownloadDirective.propDecorators = {
    "downloadOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NScanDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getPicture()
            .then((sucess) => this.onsuccess.emit(sucess))
            .catch((error) => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getPicture() {
        return new Promise((resolve, reject) => {
            this.fsv.scanPicture(this.scanOptions).then(res => {
                if (this.scanOptions.doUpload) {
                    const /** @type {?} */ options = {
                        'formData': res,
                        'entityName': this.scanOptions.entityName,
                        'metadata': this.scanOptions.metadata
                    };
                    this.fsv.upload(options).then(uri => {
                        resolve(uri);
                    }).catch(err => reject(err));
                }
                else {
                    resolve(res);
                }
            }).catch((err) => {
                return reject(err);
            });
        });
    }
}
NScanDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-scan]'
            },] },
];
/** @nocollapse */
NScanDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NScanDirective.propDecorators = {
    "scanOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NVideoDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getVideo()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getVideo() {
        return new Promise((resolve, reject) => {
            this.fsv.getVideo(this.videoOptions).then(res => {
                const /** @type {?} */ options = {
                    'formData': res,
                    'entityName': this.videoOptions.entityName,
                    'metadata': this.videoOptions.metadata
                };
                this.fsv.upload(options)
                    .then(uri => resolve(uri))
                    .catch(err => reject(err));
            }).catch(err => reject(err));
        });
    }
}
NVideoDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-video]'
            },] },
];
/** @nocollapse */
NVideoDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NVideoDirective.propDecorators = {
    "videoOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NBarcodeDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getBarcode()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getBarcode() {
        return new Promise((resolve, reject) => {
            this.fsv.getBarcode(this.barcodeOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NBarcodeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-barcode]'
            },] },
];
/** @nocollapse */
NBarcodeDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NBarcodeDirective.propDecorators = {
    "barcodeOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NTtsDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getTts()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getTts() {
        return new Promise((resolve, reject) => {
            this.fsv.getTts(this.ttsOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NTtsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-tts]'
            },] },
];
/** @nocollapse */
NTtsDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NTtsDirective.propDecorators = {
    "ttsOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NFingerprintDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getFingerprint()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getFingerprint() {
        return new Promise((resolve, reject) => {
            this.fsv.getFingerprint(this.fingerprintOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NFingerprintDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-fingerprint]'
            },] },
];
/** @nocollapse */
NFingerprintDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NFingerprintDirective.propDecorators = {
    "fingerprintOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NOcrDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getOcr()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getOcr() {
        return new Promise((resolve, reject) => {
            this.fsv.getOcr(this.ocrOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NOcrDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-ocr]'
            },] },
];
/** @nocollapse */
NOcrDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NOcrDirective.propDecorators = {
    "ocrOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NShakeDirective {
    /**
     * @param {?} fsv
     */
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * @return {?}
     */
    methodToHandleMouseClickAction() {
        this.getShake()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    /**
     * @return {?}
     */
    getShake() {
        return new Promise((resolve, reject) => {
            this.fsv.getShake(this.shakeOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NShakeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-shake]'
            },] },
];
/** @nocollapse */
NShakeDirective.ctorParameters = () => [
    { type: NFileIOService, },
];
NShakeDirective.propDecorators = {
    "shakeOptions": [{ type: Input },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
    "methodToHandleMouseClickAction": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NFileUploadComponent {
    /**
     * @param {?} fileIOService
     * @param {?} _renderer
     */
    constructor(fileIOService, _renderer) {
        this.fileIOService = fileIOService;
        this._renderer = _renderer;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * Method executed when upload button is clicked.
     * @return {?}
     */
    handleUpload() {
        this.isDone = false;
        if (this.file && this.uploadOptions && this.uploadOptions.entityName && this.uploadOptions.metadata) {
            this.fileIOService.upload({ files: this.file, entityName: this.uploadOptions.entityName, metadata: this.uploadOptions.metadata })
                .then((res) => {
                this.isDone = true;
                this.onsuccess.emit(res);
            })
                .catch(err => this.onerror.emit(err));
        }
        else {
            this.onerror.emit(new Error('Upload options missing'));
        }
    }
    /**
     * Method executed when a file is selected.
     * @param {?} fileInput
     * @return {?}
     */
    handleSelect(fileInput) {
        if (fileInput.target.files && fileInput.target.files[0]) {
            this.file = fileInput.target.files[0];
            this.fileName = this.file.name;
        }
    }
    /**
     * Methods executed when cancel button is clicked.
     * Clears files.
     * @return {?}
     */
    cancel() {
        this.file = null;
        this.fileName = null;
        this.isDone = false;
        // check if the file input is rendered before clearing it
        if (this.fileInput) {
            this._renderer.setProperty(this.fileInput, 'value', '');
        }
    }
    /**
     * @return {?}
     */
    disableFileUploadButton() {
        if (typeof this.disableButton === 'boolean') {
            return this.disableButton;
        }
        return this.disableButton === 'disabled' || this.disableButton === 'true' ? true : false;
    }
}
NFileUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-file-upload',
                styles: [`.bh-file-upload{padding-left:8px;padding-right:8px}.bh-file-upload-cancel{height:24px;width:24px;position:relative;top:24px;left:-12px}::ng-deep [dir=rtl] .bh-file-upload-cancel{right:-12px;left:0}.bh-file-upload-cancel mat-icon{border-radius:12px;vertical-align:baseline}.bh-file-upload-done{height:24px;width:24px;position:relative;top:20px;left:-13px}::ng-deep [dir=rtl] .bh-file-upload-done{right:-12px;left:0}.bh-file-upload-done mat-icon{border-radius:12px;vertical-align:baseline}`],
                template: `<div>
  <button mat-raised-button class="bh-file-upload" (click)="fileInput.click()" (keyup)="fileInput.click()" color="primary"
    *ngIf="!fileName" [disabled]="disableFileUploadButton()">
    <mat-icon>attach_file</mat-icon>
    <span>Choose a file...</span>
    <input #fileInput type="file" (change)="handleSelect($event)" style="display:none;" />
  </button>
  <div *ngIf="fileName">
    <button mat-raised-button color="primary" (click)="handleUpload()">
      <mat-icon>file_upload</mat-icon>
      <span>{{fileName}}</span>
    </button>
    <button *ngIf="!isDone" mat-icon-button color="warn" (click)="cancel()" class="bh-file-upload-cancel">
      <mat-icon>cancel</mat-icon>
    </button>
    <button *ngIf="isDone" mat-icon-button (click)="cancel()" class="bh-file-upload-done">
      <mat-icon>done</mat-icon>
    </button>
  </div>
</div>
`,
            },] },
];
/** @nocollapse */
NFileUploadComponent.ctorParameters = () => [
    { type: NFileIOService, },
    { type: Renderer2, },
];
NFileUploadComponent.propDecorators = {
    "fileInput": [{ type: ViewChild, args: ['fileInput',] },],
    "uploadOptions": [{ type: Input },],
    "disableButton": [{ type: Input, args: ['disabled',] },],
    "onsuccess": [{ type: Output },],
    "onerror": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NAlertComponent {
    /**
     * @param {?=} dialogRef
     */
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
        this.messageContent = NAlertComponent.message;
        this.titleContent = NAlertComponent.title;
    }
}
NAlertComponent.title = '';
NAlertComponent.message = '';
NAlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-alert-dialog',
                template: `
<div class="alertContainer" fxLayout="column">
  <h4 mat-dialog-title>{{titleContent}}</h4>
  <span class="msgContainer" >{{messageContent}}</span>
  <button mat-raised-button (click)="dialogRef.close()">Close</button>
</div>
`,
                styles: [`.alertContainer{height:auto;width:auto}.msgContainer{margin-bottom:.5em}`]
            },] },
];
/** @nocollapse */
NAlertComponent.ctorParameters = () => [
    { type: MatDialogRef, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NAlertService {
    /**
     * @param {?} dialog
     */
    constructor(dialog) {
        this.dialog = dialog;
    }
    /**
     * @param {?} message
     * @param {?} title
     * @param {?=} data
     * @return {?}
     */
    alert(message, title, data) {
        NAlertComponent.message = message;
        NAlertComponent.title = title;
        this.dialog.open(NAlertComponent, data);
    }
}
NAlertService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NAlertService.ctorParameters = () => [
    { type: MatDialog, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NToggleoptionsComponent {
    constructor() {
        // options = {icon: 'home', value: 'home', disabled: false, 'checked': false}
        this.toggleOptions = [];
        this.align = 'horizontal';
        this.indexChange = new EventEmitter();
        this.valueChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        if (this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['checkedIndex'] && this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        else if (changes['disabledIndex'] && this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    optionClicked(index) {
        if (this.toggleOptions && this.toggleOptions.length > 0) {
            this.indexChange.emit(index);
            if (this.toggleOptions[index] && this.toggleOptions[index].value) {
                this.valueChange.emit(this.toggleOptions[index].value);
            }
            else {
                // this.snackbar.open('Invalid toggle button value', 'OK');
            }
        }
        else {
            // this.snackbar.open('Invalid toggle options', 'OK');
        }
    }
    /**
     * @param {?} number
     * @return {?}
     */
    checkNumber(number) {
        if (number !== undefined && number !== null) {
            return Number.isNaN(Number(number));
        }
        return false;
    }
}
NToggleoptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-toggleoptions',
                template: `<mat-button-toggle-group #group="matButtonToggleGroup" [vertical]="align == 'vertical'? true: false">
    <mat-button-toggle *ngFor="let option of toggleOptions; let i = index;" [value]="option.value" [disabled]="option.disabled || disabledIndex == i" [checked]="option.checked || checkedIndex == i" (click)="optionClicked(i)" fxLayoutAlign="center center">
        <mat-icon *ngIf="option.icon">{{option.icon}}</mat-icon>
        <span *ngIf="!option.icon && option.value">{{option.value}}</span>
    </mat-button-toggle>
</mat-button-toggle-group>`
            },] },
];
/** @nocollapse */
NToggleoptionsComponent.propDecorators = {
    "toggleOptions": [{ type: Input, args: ['toggleOptions',] },],
    "align": [{ type: Input, args: ['align',] },],
    "disabledIndex": [{ type: Input, args: ['disabledIndex',] },],
    "checkedIndex": [{ type: Input, args: ['checkedIndex',] },],
    "indexChange": [{ type: Output },],
    "valueChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Service import Example :
 * import { HeroService } from '../services/hero/hero.service';
 */
class NSignatureComponent {
    constructor() {
        this.imageDataValue = '';
        this.signaturePad = '';
        this.mode = 'responsive';
        this.canvasMode = 'responsive';
        this.imageDataChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get imageData() {
        return this.imageDataValue;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set imageData(val) {
        this.imageDataValue = val;
        if (val || val === '' || this.isDataURL(val)) {
            this.saveCavas(val);
        }
        this.imageDataChange.emit(this.imageDataValue);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.mode === 'responsive') {
            this.createCanvas();
        }
    }
    /**
     * @return {?}
     */
    createCanvas() {
        this.fitToContainer(this.signaturecanvas.nativeElement);
        this.signaturePad = new signing__default(this.signaturecanvas.nativeElement, this.assignOptions());
    }
    /**
     * @param {?=} dataUrl
     * @return {?}
     */
    saveCavas(dataUrl) {
        if (this.signaturePad) {
            if (this.signaturePad.isEmpty() || dataUrl === '') {
                this.savedData = '';
                this.signaturePad.clear();
            }
            else if (this.isDataURL(dataUrl)) {
                this.signaturePad.fromDataURL(dataUrl);
                this.savedData = this.signaturePad.toData();
            }
            else {
                this.imageData = this.signaturePad.toDataURL();
                if (this.mode === 'click-fullscreen') {
                    this.savedData = this.signaturePad.toData();
                    this.hideCanvas();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    clearCanvas() {
        this.signaturePad.clear();
        // this.fitToContainer(this.signaturecanvas.nativeElement);
    }
    /**
     * @return {?}
     */
    undoCanvas() {
        const /** @type {?} */ data = this.signaturePad.toData();
        if (data) {
            data.pop(); // remove the last dot or line
            this.signaturePad.fromData(data);
        }
    }
    /**
     * @return {?}
     */
    showCanvas() {
        this.classAbs = true;
        this.canvasMode = 'fullscreen';
        if (!this.signaturePad) {
            this.createCanvas();
        }
        this.fitToContainer(this.signaturecanvas.nativeElement, document.body.clientHeight, document.body.clientWidth);
        this.clearCanvas();
        this.createCanvasFromData();
    }
    /**
     * @return {?}
     */
    hideCanvas() {
        this.canvasMode = 'responsive';
    }
    /**
     * @return {?}
     */
    cancel() {
        this.savedData = Object.assign([], this.previousSavedData);
    }
    /**
     * @return {?}
     */
    createCanvasFromData() {
        if (this.savedData) {
            this.previousSavedData = Object.assign({}, this.savedData);
            this.signaturePad.fromData(this.savedData);
        }
    }
    /**
     * @param {?} element
     * @param {?=} height
     * @param {?=} width
     * @return {?}
     */
    fitToContainer(element, height, width) {
        element.style.width = '100%';
        element.style.height = 'calc(100% - 56px)';
        if (height && width) {
            element.width = width;
            element.height = height - 56;
        }
        else {
            element.width = element.offsetWidth;
            element.height = element.offsetHeight;
        }
    }
    /**
     * @return {?}
     */
    assignOptions() {
        let /** @type {?} */ options = {};
        options['backgroundColor'] = this.checkIfValidValueAndRGB(this.backgroundColor, 'backgroundColor');
        options['dotSize'] = this.checkIfValidValueAndNumber(this.dotSize, 'dotSize');
        options['minWidth'] = this.checkIfValidValueAndNumber(this.minWidth, 'minWidth');
        options['maxWidth'] = this.checkIfValidValueAndNumber(this.maxWidth, 'maxWidth');
        options['throttle'] = this.checkIfValidValueAndNumber(this.throttle, 'throttle');
        options['minDistance'] = this.checkIfValidValueAndNumber(this.minDistance, 'minDistance');
        options['penColor'] = this.checkIfValidValueAndRGB(this.penColor, 'penColor');
        options['velocityFilterWeight'] = this.checkIfValidValueAndNumber(this.velocityFilterWeight, 'velocityFilterWeight');
        options = JSON.parse(JSON.stringify(options)); // removing all undefined fields
        options['onBegin'] = this.checkIfValidValueAndFunction(this.onBegin, 'onBegin');
        options['onEnd'] = this.checkIfValidValueAndFunction(this.onEnd, 'onEnd');
        return options;
    }
    /**
     * @param {?} num
     * @param {?} name
     * @return {?}
     */
    checkIfValidValueAndNumber(num, name) {
        if (this.checkIfValid(num) && this.checkNumber(num)) {
            return num;
        }
        this.invalidToast(name, 'num');
        return undefined;
    }
    /**
     * @param {?} color
     * @param {?} name
     * @return {?}
     */
    checkIfValidValueAndRGB(color, name) {
        if (this.checkIfValid(color) && this.checkRGB(color)) {
            return color;
        }
        this.invalidToast(name, 'rgb');
        return undefined;
    }
    /**
     * @param {?} fn
     * @param {?} name
     * @return {?}
     */
    checkIfValidValueAndFunction(fn, name) {
        if (this.checkIfValid(fn) && this.checkIfValidFunction(fn)) {
            return fn;
        }
        this.invalidToast(name, 'function format');
        return undefined;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    checkIfValid(value) {
        return (value !== undefined && value !== null) ? value : undefined;
    }
    /**
     * @param {?} num
     * @return {?}
     */
    checkNumber(num) {
        return !this.checkIsNan(Number(num)) ? Number(num) : undefined;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    checkIfValidFunction(fn) {
        return typeof fn === 'function' ? fn : undefined;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    checkRGB(color) {
        const /** @type {?} */ matchColors1 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/);
        const /** @type {?} */ matchColors2 = new RegExp(/rgb\((\d{1,3}),[ \t]+(\d{1,3}),(\d{1,3})\)/);
        const /** @type {?} */ matchColors3 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),[ \t]+(\d{1,3})\)/);
        return matchColors1.test(color) || matchColors2.test(color) || matchColors3.test(color);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    checkIsNan(value) {
        return Number.isNaN(value);
    }
    /**
     * @param {?} optionName
     * @param {?} optionType
     * @return {?}
     */
    invalidToast(optionName, optionType) {
        return;
    }
    /**
     * @param {?} s
     * @return {?}
     */
    isDataURL(s) {
        if (s) {
            const /** @type {?} */ regex = /^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i;
            return !!s.match(regex);
        }
        else {
            return false;
        }
    }
}
NSignatureComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-signature',
                template: `<div fxFill fxLayout="row" *ngIf="mode == 'click-fullscreen' && canvasMode !== 'fullscreen'" class="signature-component-border">
    <div fxFlex="calc(100%-56px)" fxLayout="column">
        <img *ngIf="imageDataValue" [src]="imageDataValue" fxFill/>
    </div>
    <div fxFlex="56px" fxLayoutAlign=" center" class="signature-component-border">
        <button mat-icon-button (click)="showCanvas()">
            <mat-icon>mode_edit</mat-icon>
        </button>
    </div>
</div>
<div fxFill fxLayout="column" class="signature-component-border" [fxShow]="(mode == 'click-fullscreen' && canvasMode == 'fullscreen') || mode == 'responsive'" [ngClass]="{'signature-canvas-fullscreen': classAbs}">
    <canvas #signaturecanvas></canvas>
    <div fxFlex="56px" fxLayoutAlign="center center" class="signature-component-border">
        <button mat-icon-button (click)="undoCanvas()">
            <mat-icon>undo</mat-icon>
        </button>
        <button mat-icon-button (click)="clearCanvas()">
            <mat-icon>loop</mat-icon>
        </button>
        <button mat-icon-button (click)="saveCavas()">
            <mat-icon>save</mat-icon>
        </button>
        <button mat-icon-button (click)="canvasMode = 'responsive'; cancel()">
            <mat-icon>clear</mat-icon>
        </button>
    </div>
</div>`,
                styles: [`
     :host { height: 100% !important; }
     .signature-canvas-fullscreen {
         position: absolute;
         top: 0;
         bottom: 0;
         right: 0;
         left: 0;
     }
     .signature-component-border {
         border: 2px solid black;
     }
    `]
            },] },
];
/** @nocollapse */
NSignatureComponent.propDecorators = {
    "signaturecanvas": [{ type: ViewChild, args: ['signaturecanvas',] },],
    "canvasparent": [{ type: ViewChild, args: ['canvasparent',] },],
    "backgroundColor": [{ type: Input, args: ['backgroundColor',] },],
    "dotSize": [{ type: Input, args: ['dotSize',] },],
    "minWidth": [{ type: Input, args: ['minWidth',] },],
    "maxWidth": [{ type: Input, args: ['maxWidth',] },],
    "throttle": [{ type: Input, args: ['throttle',] },],
    "minDistance": [{ type: Input, args: ['minDistance',] },],
    "penColor": [{ type: Input, args: ['penColor',] },],
    "velocityFilterWeight": [{ type: Input, args: ['velocityFilterWeight',] },],
    "onBegin": [{ type: Input, args: ['onBegin',] },],
    "onEnd": [{ type: Input, args: ['onEnd',] },],
    "mode": [{ type: Input, args: ['mode',] },],
    "imageDataChange": [{ type: Output },],
    "imageData": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const EXPORTS = [
    NCameraDirective,
    NDownloadDirective,
    NScanDirective,
    NVideoDirective,
    NBarcodeDirective,
    NTtsDirective,
    NFingerprintDirective,
    NOcrDirective,
    NShakeDirective,
    NFileUploadComponent,
    NAlertComponent,
    NToggleoptionsComponent,
    NSignatureComponent,
];
class NeutrinosModule {
}
NeutrinosModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                    FormsModule,
                    CommonModule,
                    MatIconModule,
                    MatDialogModule,
                    MatButtonModule,
                    BrowserAnimationsModule,
                    MatButtonToggleModule,
                    NeutrinosSeedServicesModule,
                    NSheetModule,
                    FlexLayoutModule,
                ],
                declarations: [
                    EXPORTS,
                ],
                exports: [
                    EXPORTS,
                    NFileUploadComponent,
                    NeutrinosSeedServicesModule,
                    NSheetModule
                ],
                providers: [
                    NFileIOService,
                    NAlertService
                ],
                entryComponents: [
                    NAlertComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NFileIOService, NAlertComponent, NFileUploadComponent, NAlertService, NeutrinosModule, NSignatureComponent as k, NToggleoptionsComponent as j, NBarcodeDirective as e, NCameraDirective as a, NDownloadDirective as b, NFingerprintDirective as g, NOcrDirective as h, NScanDirective as c, NShakeDirective as i, NTtsDirective as f, NVideoDirective as d };
//# sourceMappingURL=neutrinos-module.js.map
